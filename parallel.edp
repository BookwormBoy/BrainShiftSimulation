load "msh3"
load "tetgen"
load "medit"
include "MeshSurface.idp"
load "PETSc"
// load "bem"

// Mesh Parameters
real brainRadius = 1;
real brainMeshSize = 0.4;

real tumourRadius = 0.1;
real tumourMeshSize = 0.4;

//Simulation Parameters
real rho = 1036;    // Density (e.g., for brain tissue)
real E = 3000;      // Young's Modulus (Pa)
real nu = 0.4925;     // Poisson's Ratio
real g = -9.81;  

real Tfinal = 0.1;
real dt = 0.01;
real nsteps=Tfinal/dt;
// Lam√© parameters
real mu = E / (2 * (1 + nu));
real lambda = E * nu / ((1 + nu) * (1 - 2 * nu));

real alpha = 0.02;   // Mass-proportional damping coefficient
real beta = 0.02;

// Newton-Raphson Solver Parameters
int maxiter = 100;
real tol = 1e-6;

//fluid region
real rhoFluid = 1000;  
real hFluid = 0.0;
// The outer sphere, defining region 1
meshS brain = Sphere(brainRadius, brainMeshSize, 10, 0, 0, 0, 1);

// The inner sphere, marked as a hole, defining region 2
meshS tumour = Sphere(tumourRadius, tumourMeshSize, 20, 0.3, 0.3, 0.3, 1);

meshS consolidatedMesh = brain + tumour;

real voltet = (brainMeshSize^3)/6.;
cout << "voltet = " << voltet << endl;

real[int] domain = [0.0, 0.0, 0.0, 1, voltet,   // Seed for brain region
                    0.3, 0.3, 0.3, 2, voltet];  // Seed for tumour region

mesh3 Th = tetg(consolidatedMesh, switch="pqaAAYYQ", nbofregions=2, regionlist=domain);

// fespace Ph(Th, P0); //constant discontinuous functions / element
// Ph reg=region; //defined the P0 function associated to region number
// plot(reg, fill=true, wait=true, value=true);

fespace Vh(Th, P1);
fespace Vh3(Th, [P1, P1, P1]); // Vector space for displacement

// Current and reference coordinates
Vh3 [u1, u2, u3] = [0, 0, 0];     // Current displacement
Vh3 [du1, du2, du3] = [0, 0, 0];  // Displacement increment
Vh3 [Du1, Du2, Du3] = [0, 0, 0];  // Displacement increment accumulated over the iteration
Vh3 [v1, v2, v3] = [0, 0, 0]; //Test functions
Vh3 [ut1, ut2, ut3] = [0, 0, 0];     // Displacement from the previous time step
Vh3 [at1, at2, at3] = [0, 0, 0];     // acceleration from previous time step
Vh3 [vt1, vt2, vt3] = [0, 0, 0];     // velocity from prev time step
Vh3 [vk1, vk2, vk3] = [0, 0, 0];     //current guess for vel at iteration k in NR
Vh3 [ak1, ak2, ak3] = [0, 0, 0];     //current guess for acc at iteration k in NR
Vh3 [an1, an2, an3] = [0, 0, 0];     //term to update mass matrix
// Vh3 [f1, f2, f3] = [0, 0, 0]; //fluid force acting on the node at a particular time step
Vh f1=0;
Vh f2=0;
Vh f3=0;

Vh S11, S22, S12, S33, S13, S23 = 0; // Stress components

real csfHeight = 1.0;
real cutHeight = 0.0;


 

//Tensor macros

//Incremental 2PK stress tensor
macro oS11(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e11(du1,du2,du3,u1,u2,u3)) //
macro oS22(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e22(du1,du2,du3,u1,u2,u3)) //
macro oS33(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e33(du1,du2,du3,u1,u2,u3)) //

macro oS12(du1,du2,du3, u1,u2,u3) (2*mu*e12(du1,du2,du3,u1,u2,u3)) //
macro oS13(du1,du2,du3, u1,u2,u3) (2*mu*e13(du1,du2,du3,u1,u2,u3)) //
macro oS23(du1,du2,du3, u1,u2,u3) (2*mu*e23(du1,du2,du3,u1,u2,u3)) //

// Incremental linear strain (eij)
macro e11(du1,du2,du3, u1,u2,u3) (dx(du1) + dx(u1)*dx(du1) + dx(u2)*dx(du2) + dx(u3)*dx(du3)) //
macro e22(du1,du2,du3, u1,u2,u3) (dy(du2) + dy(u1)*dy(du1) + dy(u2)*dy(du2) + dy(u3)*dy(du3)) //
macro e33(du1,du2,du3, u1,u2,u3) (dz(du3) + dz(u1)*dz(du1) + dz(u2)*dz(du2) + dz(u3)*dz(du3)) //
// Incremental linear strain (eij) - CORRECTED
macro e12(du1,du2,du3, u1,u2,u3) (0.5*(dy(du1) + dx(du2) + (dx(du1)*dy(u1) + dx(u1)*dy(du1)) + (dx(du2)*dy(u2) + dx(u2)*dy(du2)) + (dx(du3)*dy(u3) + dx(u3)*dy(du3)) )) //
macro e13(du1,du2,du3, u1,u2,u3) (0.5*(dz(du1) + dx(du3) + (dx(du1)*dz(u1) + dx(u1)*dz(du1)) + (dx(du2)*dz(u2) + dx(u2)*dz(du2)) + (dx(du3)*dz(u3) + dx(u3)*dz(du3)) )) //
macro e23(du1,du2,du3, u1,u2,u3) (0.5*(dz(du2) + dy(du3) + (dy(du1)*dz(u1) + dy(u1)*dz(du1)) + (dy(du2)*dz(u2) + dy(u2)*dz(du2)) + (dy(du3)*dz(u3) + dy(u3)*dz(du3)) )) //
macro tre(du1,du2,du3, u1,u2,u3) (e11(du1,du2,du3,u1,u2,u3) + e22(du1,du2,du3,u1,u2,u3) + e33(du1,du2,du3,u1,u2,u3)) //

// Variation of linear strain (deij)
macro de11(v1,v2,v3, u1,u2,u3) (dx(v1) + dx(u1)*dx(v1) + dx(u2)*dx(v2) + dx(u3)*dx(v3)) //
macro de22(v1,v2,v3, u1,u2,u3) (dy(v2) + dy(u1)*dy(v1) + dy(u2)*dy(v2) + dy(u3)*dy(v3)) //
macro de33(v1,v2,v3, u1,u2,u3) (dz(v3) + dz(u1)*dz(v1) + dz(u2)*dz(v2) + dz(u3)*dz(v3)) //

// Variation of linear strain (deij) - CORRECTED
macro de12(v1,v2,v3, u1,u2,u3) (0.5*(dy(v1) + dx(v2) + (dx(v1))*(dy(u1)) + (dx(u1))*(dy(v1)) + (dx(v2))*(dy(u2)) + (dx(u2))*(dy(v2)) + (dx(v3))*(dy(u3)) + (dx(u3))*(dy(v3)))) //

macro de13(v1,v2,v3, u1,u2,u3) (0.5*(dz(v1) + dx(v3) + (dx(v1))*(dz(u1)) + (dx(u1))*(dz(v1)) + (dx(v2))*(dz(u2)) + (dx(u2))*(dz(v2)) + (dx(v3))*(dz(u3)) + (dx(u3))*(dz(v3)))) //

macro de23(v1,v2,v3, u1,u2,u3) (0.5*(dz(v2) + dy(v3) + (dy(v1))*(dz(u1)) + (dy(u1))*(dz(v1)) + (dy(v2))*(dz(u2)) + (dy(u2))*(dz(v2)) + (dy(v3))*(dz(u3)) + (dy(u3))*(dz(v3)))) //

// Variation of incremental nonlinear strain (dnij)
macro dn11(du1,du2,du3, v1,v2,v3) (dx(v1)*dx(du1) + dx(v2)*dx(du2) + dx(v3)*dx(du3)) //
macro dn22(du1,du2,du3, v1,v2,v3) (dy(v1)*dy(du1) + dy(v2)*dy(du2) + dy(v3)*dy(du3)) //
macro dn33(du1,du2,du3, v1,v2,v3) (dz(v1)*dz(du1) + dz(v2)*dz(du2) + dz(v3)*dz(du3)) //

macro dn12(du1,du2,du3, v1,v2,v3) (0.5*(dx(v1)*dy(du1) + dy(v1)*dx(du1) + dx(v2)*dy(du2) + dy(v2)*dx(du2) + dx(v3)*dy(du3) + dy(v3)*dx(du3)) ) //
macro dn13(du1,du2,du3, v1,v2,v3) (0.5*(dx(v1)*dz(du1) + dz(v1)*dx(du1) + dx(v2)*dz(du2) + dz(v2)*dx(du2) + dx(v3)*dz(du3) + dz(v3)*dx(du3)) ) //
macro dn23(du1,du2,du3, v1,v2,v3) (0.5*(dy(v1)*dz(du1) + dz(v1)*dy(du1) + dy(v2)*dz(du2) + dz(v2)*dy(du2) + dy(v3)*dz(du3) + dz(v3)*dy(du3)) ) //

macro crossProductX(Ax, Ay, Az, Bx, By, Bz) (Ay*Bz - Az*By)//
macro crossProductY(Ax, Ay, Az, Bx, By, Bz) (Az*Bx - Ax*Bz)//
macro crossProductZ(Ax, Ay, Az, Bx, By, Bz) (Ax*By - Ay*Bx)//


varf vMass([du1,du2,du3], [v1,v2,v3]) = int3d(Th)(rho * (du1*v1 + du2*v2 + du3*v3));

// Assemble the consistent mass matrix
matrix Mconsistent = vMass(Vh3, Vh3);

real[int] ones(Vh3.ndof);
ones = 1.0;

// Use the row-sum lumping shortcut to get the diagonal vector
real[int] Mlumpeddiag = Mconsistent * ones; // Dofones is a built-in vector of 1s

// Create the final, constant, lumped (diagonal) mass matrix M
matrix M = Mlumpeddiag;

cout << "Lumped Mass Matrix M constructed." << endl;

real[int] pinMask(Vh3.ndof);
// cout<<"OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO "<<Vh.ndof<<" "<<Th.nv<<endl; 
for (int i = 0; i < Th.nv; i++) {
    if (Th(i).y < 0) {
        // For a P1 element, the DOFs are associated with the vertices.
        // We need to pin all three displacement components (x, y, and z).
        pinMask[i*3 + 0] = 1.0; // u1 component
        pinMask[i*3 + 1] = 1.0; // u2 component
        pinMask[i*3 + 2] = 1.0; // u3 component
    }
}

//variatonal form to solve residual 
varf residual([du1,du2,du3], [v1,v2,v3]) =

    // Internal forces (Sij::deij)
    - int3d(Th)( 
           S11*de11(v1,v2,v3, u1,u2,u3) 
         + S22*de22(v1,v2,v3, u1,u2,u3)
         + S33*de33(v1,v2,v3, u1,u2,u3)  
         + 2*S12*de12(v1,v2,v3, u1,u2,u3)
         + 2*S13*de13(v1,v2,v3, u1,u2,u3) 
         + 2*S23*de23(v1,v2,v3, u1,u2,u3)  
    )

    //External forces (only gravity for now, fluid force to be added)
    + int3d(Th)( 
        rho * g * v3
    )

    + int3d(Th)(f1*v1 + f2*v2 + f3*v3)

    + on(10, du1=0, du2=0, du3=0);
    

varf effectiveSystem(<[du1,du2,du3]>, <[v1,v2,v3]>) =
    // K_tangent part (Stiffness + Geometric) multiplied by damping factor
        int3d(Th)(
            
              de11(v1,v2,v3, u1,u2,u3) * oS11(du1,du2,du3, u1,u2,u3)
            + de22(v1,v2,v3, u1,u2,u3) * oS22(du1,du2,du3, u1,u2,u3)
            + de33(v1,v2,v3, u1,u2,u3) * oS33(du1,du2,du3, u1,u2,u3)
            + 2*de12(v1,v2,v3, u1,u2,u3) * oS12(du1,du2,du3, u1,u2,u3)
            + 2*de13(v1,v2,v3, u1,u2,u3) * oS13(du1,du2,du3, u1,u2,u3)
            + 2*de23(v1,v2,v3, u1,u2,u3) * oS23(du1,du2,du3, u1,u2,u3)
        )
        // Geometric Part (K_NL)
        + int3d(Th)(
              S11*dn11(du1,du2,du3, v1,v2,v3) + S22*dn22(du1,du2,du3, v1,v2,v3) + S33*dn33(du1,du2,du3, v1,v2,v3)
            + 2*S12*dn12(du1,du2,du3, v1,v2,v3) + 2*S13*dn13(du1,du2,du3, v1,v2,v3) + 2*S23*dn23(du1,du2,du3, v1,v2,v3)
        )
    
    // Mass Part (M) multiplied by its factors
        + int3d(Th)(
            (4./(dt*dt) + alpha * 2./dt) * rho * (du1*v1 + du2*v2 + du3*v3)
        )
    // Boundary Condition
    + on(10, du1=0, du2=0, du3=0);

matrix Ktemplate = effectiveSystem(Vh3, Vh3);

// 2. Create the PETSc parallel matrix (Mat) using the template.
//    Keff is now a properly initialized, distributed PETSc matrix.
Mat Keff(Ktemplate);

func real calculateFluidForce(real csfHeight) {
    Vh xDeformed = x+u1;
    Vh yDeformed = y+u2;
    Vh zDeformed = z+u3;

    f1[] = 0;
    f2[] = 0;
    f3[] = 0;
    // medit("Fluid Force Vectors", Th, f1, wait=true);


    int nbe = Th.nbe;

    for(int i=0;i<nbe;i++){


        //Getting the indices of the vertices for this surface triangle
        int i1 = Th.be(i)[0];
        int i2 = Th.be(i)[1];
        int i3 = Th.be(i)[2];

        //Getting the z values for those vertices
        real z1 = zDeformed[][i1];
        real z2 = zDeformed[][i2];
        real z3 = zDeformed[][i3];

        real x1 = xDeformed[][i1];
        real x2 = xDeformed[][i2];
        real x3 = xDeformed[][i3];

        real y1 = yDeformed[][i1];
        real y2 = yDeformed[][i2];
        real y3 = yDeformed[][i3];

        real r1 = x1*x1+ y1*y1 + z1*z1;
        real r2 = x2*x2 + y2*y2 + z2*z2;
        real r3 = x3*x3 + y3*y3 + z3*z3;
        if((r1 + r2 + r3)<2.5){continue;}
        // cout<<"Triangle "<<i<<"V1: "<<r1<<" V2: "<<r2<<" V3: "<<r3<<endl;

        int submergedCount=0;
        if(z1<=csfHeight) submergedCount++;
        if(z2<=csfHeight) submergedCount++;
        if(z3<=csfHeight) submergedCount++;

        //getting vertex positions for the three vertices
        real[int] j1 = [xDeformed[][i1], yDeformed[][i1], z1]; 
        real[int] j2 = [xDeformed[][i2], yDeformed[][i2], z2];
        real[int] j3 = [xDeformed[][i3], yDeformed[][i3], z3];

        real[int] v1 = [j2[0]-j1[0], j2[1]-j1[1], j2[2]-j1[2]];
        real[int] v2 = [j3[0]-j1[0], j3[1]-j1[1], j3[2]-j1[2]];

        real n1 = crossProductX(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
        real n2 = crossProductY(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
        real n3 = crossProductZ(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
        real mag = sqrt(n1*n1 + n2*n2 + n3*n3);
        real[int] n = [-n1/mag, -n2/mag, -n3/mag]; //unit normal vector


        //All three nodes submerged
        if(submergedCount==3){

            //calculating centroid
            real g1 = j1[0] + j2[0] + j3[0];
            real g2 = j1[1] + j2[1] + j3[1];
            real g3 = j1[2] + j2[2] + j3[2];

            real[int] G = [g1/3, g2/3, g3/3];
            
            

            real S = 0.5*mag;

            real fluidFactor = -(rhoFluid)*abs(g)*(csfHeight - G[2])*S;


            real[int] fluidForce = [fluidFactor * n[0], fluidFactor * n[1], fluidFactor*n[2]];

            real h1 = csfHeight - z1;
            real h2 = csfHeight - z2;
            real h3 = csfHeight - z3;
            real hSum = h1 + h2 + h3;

            //updating fluid force for this time step
            if(hSum > 1e-9){
                f1[][i1] += fluidForce[0] * h1/hSum;
                f2[][i1] += fluidForce[1] * h1/hSum;
                f3[][i1] += fluidForce[2] * h1/hSum;

                f1[][i2] += fluidForce[0] * h2/hSum;
                f2[][i2] += fluidForce[1] * h2/hSum;
                f3[][i2] += fluidForce[2] * h2/hSum;

                f1[][i3] += fluidForce[0] * h3/hSum;
                f2[][i3] += fluidForce[1] * h3/hSum;
                f3[][i3] += fluidForce[2] * h3/hSum;
            }

        }

        if(submergedCount==2){
            real[int] psub1 = [0, 0, 0];
            real[int] psub2 = [0, 0, 0];
            real[int] pair = [0, 0, 0];

            int isub1, isub2 = 0;

            if (z1 > csfHeight) { pair = j1; psub1 = j2; isub1 = i2; psub2 = j3; isub2 = i3;}
            else if (z2 > csfHeight) { pair = j2; psub1 = j1; isub1 = i1; psub2 = j3; isub2 = i3;}
            else { pair = j3; psub1 = j1; isub1 = i1; psub2 = j2; isub2 = i2;}

            // Calculate intersection points on the edges from submerged vertices to the air vertex
            real t1 = (csfHeight - psub1[2]) / (pair[2] - psub1[2]);

            real[int] pint1 = [psub1[0] + t1*(pair[0] - psub1[0]), psub1[1] + t1*(pair[1] - psub1[1]), psub1[2] + t1*(pair[2] - psub1[2])];

            real t2 = (csfHeight - psub2[2]) / (pair[2] - psub2[2]);

            real[int] pint2 = [psub2[0] + t2*(pair[0] - psub2[0]), psub2[1] + t2*(pair[1] - psub2[1]), psub2[2] + t2*(pair[2] - psub2[2])];

            // Force on Triangle A
            real [int] Ga = [(psub1[0] + psub2[0] + pint1[0])/3., (psub1[1] + psub2[1] + pint1[1])/3., (psub1[2] + psub2[2] + pint1[2])/3.];

            real[int] vA1 = [psub2[0] - psub1[0], psub2[1] - psub1[1], psub2[2] - psub1[2]];
            real[int] vA2 = [pint1[0] - psub1[0], pint1[1] - psub1[1], pint1[2] - psub1[2]];

            real Sa1 = crossProductX(vA1[0], vA1[1], vA1[2], vA2[0], vA2[1], vA2[2]);
            real Sa2 = crossProductY(vA1[0], vA1[1], vA1[2], vA2[0], vA2[1], vA2[2]);
            real Sa3 = crossProductZ(vA1[0], vA1[1], vA1[2], vA2[0], vA2[1], vA2[2]);

            real Sa = 0.5 * sqrt(Sa1*Sa1 + Sa2*Sa2 + Sa3*Sa3);
            real fluidFactorA = -rhoFluid *abs(g) * (csfHeight-Ga[2])*Sa;
            real[int] fluidForceA = [fluidFactorA * n[0], fluidFactorA * n[1], fluidFactorA*n[2]];

            // Force on Triangle B
            real [int] Gb = [(pint2[0] + psub2[0] + pint1[0])/3., (pint2[1] + psub2[1] + pint1[1])/3., (pint2[2] + psub2[2] + pint1[2])/3.];

            real[int] vB1 = [pint2[0] - psub2[0], pint2[1] - psub2[1], pint2[2] - psub2[2]];
            real[int] vB2 = [pint1[0] - psub2[0], pint1[1] - psub2[1], pint1[2] - psub2[2]];

            real Sb1 = crossProductX(vB1[0], vB1[1], vB1[2], vB2[0], vB2[1], vB2[2]);
            real Sb2 = crossProductY(vB1[0], vB1[1], vB1[2], vB2[0], vB2[1], vB2[2]);
            real Sb3 = crossProductZ(vB1[0], vB1[1], vB1[2], vB2[0], vB2[1], vB2[2]);

            real Sb = 0.5 * sqrt(Sb1*Sb1 + Sb2*Sb2 + Sb3*Sb3);
            real fluidFactorB = -rhoFluid *abs(g) * (csfHeight-Gb[2])*Sb;
            real[int] fluidForceB = [fluidFactorB * n[0], fluidFactorB * n[1], fluidFactorB*n[2]];

            real h1 = csfHeight - psub1[2];
            real h2 = csfHeight - psub2[2];
            real hSum = h1 + h2;
            if (hSum > 1e-9) {
                f1[][isub1] += fluidForceA[0] * h1/hSum;
                f2[][isub1] += fluidForceA[1] * h1/hSum;
                f3[][isub1] += fluidForceA[2] * h1/hSum;

                f1[][isub2] += fluidForceA[0] * h2/hSum + fluidForceB[0];
                f2[][isub2] += fluidForceA[1] * h2/hSum + fluidForceB[1];
                f3[][isub2] += fluidForceA[2] * h2/hSum + fluidForceB[2];
            }


        }
        if(submergedCount==1){
            real[int] psub = [0, 0, 0];
            real[int] pair1 = [0, 0, 0];
            real[int] pair2 = [0, 0, 0];
            int isub;

            // Find which vertex is submerged
            if (z1 <= csfHeight) { psub = j1; isub = i1; pair1 = j2; pair2 = j3;}
            else if (z2 <= csfHeight) { psub = j2; isub = i2; pair1 = j1; pair2 = j3;}
            else { psub = j3; isub = i3; pair1 = j1; pair2 = j2;}

            real t1 = (csfHeight - psub[2]) / (pair1[2] - psub[2]);
            real[int] pint1 = [psub[0] + t1 * (pair1[0] - psub[0]), psub[1] + t1 * (pair1[1] - psub[1]), psub[2] + t1 * (pair1[2] - psub[2])];

            real t2 = (csfHeight - psub[2]) / (pair2[2] - psub[2]);
            real[int] pint2 = [psub[0] + t2 * (pair2[0] - psub[0]), psub[1] + t2 * (pair2[1] - psub[1]), psub[2] + t2 * (pair2[2] - psub[2])];

            real[int] G = [(psub[0] + pint2[0] + pint1[0])/3., (psub[1] + pint2[1] + pint1[1])/3., (psub[2] + pint2[2] + pint1[2])/3.];

            real [int] v1 = [pint1[0] - psub[0], pint1[1] - psub[1], pint1[2] - psub[2]];
            real [int] v2 = [pint2[0] - psub[0], pint2[1] - psub[1], pint2[2] - psub[2]];

            real S1 = crossProductX(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
            real S2 = crossProductY(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
            real S3 = crossProductZ(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);

            real S = 0.5 * sqrt(S1*S1 + S2*S2 + S3*S3);

            real fluidFactor = -rhoFluid * abs(g) * (csfHeight - G[2]) * S;

            real[int] fluidForce = [fluidFactor * n[0], fluidFactor * n[1], fluidFactor*n[2]];
            
            f1[][isub] += fluidForce[0];
            f2[][isub] += fluidForce[1];
            f3[][isub] += fluidForce[2];

        }

    }

    // medit("Fluid Force Vectors", Th, f1, wait=true);

}


for (int step = 1; step <= nsteps; ++step) {

    real t = step * dt;
    if(mpirank==0){
    cout << "Time step: " << step << " (t = " << t << ")" << endl;
    }

    real currentCsfHeight = 1.0 + (cutHeight - 1.0) * (t / Tfinal);

    if(mpirank==0){
    cout << "  Current CSF Height = " << currentCsfHeight << endl;
    }

    calculateFluidForce(currentCsfHeight);

    Keff = effectiveSystem(Vh3, Vh3);
    // matrix Ktangent = tangent(Vh3, Vh3, solver=sparsesolver, master=-1);
    // Mat Keff = (1. + beta * 2./dt) * Ktangent + (4./(dt*dt) + alpha * 2./dt) * M;  //Included damping C = alpha*M + beta*K

    // 2. THIS IS THE CRITICAL FIX:
    //    Associate a solver with Keff and pre-factorize it.
    // set(Keff, solver=UMFPACK);

    for (int iter = 0; iter < maxiter; ++iter) {
        
        real[int] R = residual(0, Vh3); 
        // R += f1[];

        // This will now work correctly
        real[int] temp(at1[].n); // .n gives the size of the DoF vector

        // Perform the operation step-by-step
        temp = u1[] - ut1[];
        temp *= (4. / (dt*dt));
        temp -= (4. / dt) * vt1[];

        // The final, simple assignment should now work
        an1[] = temp - at1[];

        real[int] inertialForce = M * an1[];
        R -= inertialForce;
        
        real normR = R.l2;
        if(mpirank==0){
        cout << "  NR Iter: " << iter << ", Residual Norm = " << normR << endl;
        }

        // 3. CHECK FOR CONVERGENCE
        if (normR < tol) {
            if(mpirank==0){
            cout << "  -> CONVERGED" << endl;
            }
            
            // Update the total stress tensor.
            // The displacement increment for the whole step is u1[] - un1[].
            Du1[] = u1[] - ut1[];

            Vh deltaS11 = oS11(Du1, Du2, Du3, u1, u2, u3); 
            Vh deltaS22 = oS22(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS33 = oS33(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS12 = oS12(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS13 = oS13(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS23 = oS23(Du1, Du2, Du3, u1, u2, u3);
            
            S11[] += deltaS11[]; S22[] += deltaS22[]; S33[] += deltaS33[];
            S12[] += deltaS12[]; S13[] += deltaS13[]; S23[] += deltaS23[];
            
            // UPDATE STATE FOR THE NEXT STEP
            ut1[] = u1[]; 
            vt1[] = vk1[];
            at1[] = ak1[];
            
            
            break; // Exit the Newton-Raphson loop
        }
        
       
        // Solve for the correction
        du1[] = Keff^-1 * R;

        // 5. UPDATE THE DISPLACEMENT GUESS
        u1[] += du1[];

        //update acc and vel guesses
        temp = u1[] - ut1[];          
        temp *= (2. / dt);         
        vk1[] = temp - vt1[];      

        temp = u1[] - ut1[];          
        temp *= (4. / (dt*dt));     
        temp -= (4. / dt) * vt1[]; 
        ak1[] = temp - at1[];   
        
        if(iter == maxiter - 1){
            if(mpirank==0){
            cout << "  WARNING: Max iterations reached without convergence." << endl;
            }
        }
    }
}

if(mpirank == 0){
plot(u1, cmm="Final X Displacement (u1)", value=true, fill=true, wait=true);
plot(u2, cmm="Final Y Displacement (u2)", value=true, fill=true, wait=true);
plot(u3, cmm="Final Z Displacement (u3)", value=true, fill=true, wait=true);
}


// 2. Plotting the Magnitude of the Displacement Vector
// ----------------------------------------------------
// It's often more useful to see the total magnitude of displacement.
// We need a scalar (P1) space to define this function.
fespace Vh1(Th, P1);
Vh1 umagnitude = sqrt(u1^2 + u2^2 + u3^2);
if(mpirank==0){
plot(umagnitude, cmm="Displacement Magnitude", value=true, fill=true, wait=true);
}


// 3. Visualizing the Deformed Mesh using movemesh
// ------------------------------------------------
// 'movemesh' creates a NEW mesh object where the coordinates of each vertex
// have been updated by the displacement vector [u1, u2, u3].
mesh3 ThDeformed = movemesh(Th, [x+u1, y+u2, z+u3]);

// Now, plot the new, deformed mesh.
if(mpirank==0){
plot(ThDeformed, cmm="Deformed Mesh", value=true, wait=true);
plot(Th, cmm="Original", value=true, boundary=true, wait=true); // Plot original boundary
plot(ThDeformed, cmm="Deformed Mesh", value=true, wait=true);
medit("3D Mesh", ThDeformed);
}