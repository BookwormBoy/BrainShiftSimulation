load "msh3"
load "tetgen"
load "medit"
include "MeshSurface.idp"

// Mesh Parameters
real brainRadius = 1;
real brainMeshSize = 0.4;

real tumourRadius = 0.1;
real tumourMeshSize = 0.4;

//Simulation Parameters
real rho = 1050;    // Density (e.g., for brain tissue)
real E = 3000;      // Young's Modulus (Pa)
real nu = 0.49;     // Poisson's Ratio
real g = -9.81;  

real Tfinal = 0.1;
real dt = 0.01;
real nsteps=Tfinal/dt;
// Lam√© parameters
real mu = E / (2 * (1 + nu));
real lambda = E * nu / ((1 + nu) * (1 - 2 * nu));

real alpha = 0.02;   // Mass-proportional damping coefficient
real beta = 0.02;

// Newton-Raphson Solver Parameters
int maxiter = 50;
real tol = 1e-6;

//fluid region
real rhoFluid = 1000;  
real hFluid = 0.0;
// The outer sphere, defining region 1
meshS brain = Sphere(brainRadius, brainMeshSize, 10, 0, 0, 0, 1);

// The inner sphere, marked as a hole, defining region 2
meshS tumour = Sphere(tumourRadius, tumourMeshSize, 20, 0.3, 0.3, 0.3, 1);

meshS consolidatedMesh = brain + tumour;

real voltet = (brainMeshSize^3)/6.;
cout << "voltet = " << voltet << endl;

real[int] domain = [0.0, 0.0, 0.0, 1, voltet,   // Seed for brain region
                    0.3, 0.3, 0.3, 2, voltet];  // Seed for tumour region

mesh3 Th = tetg(consolidatedMesh, switch="pqaAAYYQ", nbofregions=2, regionlist=domain);

// fespace Ph(Th, P0); //constant discontinuous functions / element
// Ph reg=region; //defined the P0 function associated to region number
// plot(reg, fill=true, wait=true, value=true);

fespace Vh(Th, P1);
fespace Vh3(Th, [P1, P1, P1]); // Vector space for displacement

// Current and reference coordinates
Vh3 [u1, u2, u3] = [0, 0, 0];     // Current displacement
Vh3 [du1, du2, du3] = [0, 0, 0];  // Displacement increment
Vh3 [Du1, Du2, Du3] = [0, 0, 0];  // Displacement increment accumulated over the iteration
Vh3 [v1, v2, v3] = [0, 0, 0]; //Test functions
Vh3 [ut1, ut2, ut3] = [0, 0, 0];     // Displacement from the previous time step
Vh3 [at1, at2, at3] = [0, 0, 0];     // acceleration from previous time step
Vh3 [vt1, vt2, vt3] = [0, 0, 0];     // velocity from prev time step
Vh3 [vk1, vk2, vk3] = [0, 0, 0];     //current guess for vel at iteration k in NR
Vh3 [ak1, ak2, ak3] = [0, 0, 0];     //current guess for acc at iteration k in NR
Vh3 [an1, an2, an3] = [0, 0, 0];     //term to update mass matrix

Vh S11, S22, S12, S33, S13, S23 = 0; // Stress components
 

//Tensor macros

//Incremental 2PK stress tensor
macro oS11(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e11(du1,du2,du3,u1,u2,u3)) //
macro oS22(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e22(du1,du2,du3,u1,u2,u3)) //
macro oS33(du1,du2,du3, u1,u2,u3) (lambda*tre(du1,du2,du3,u1,u2,u3) + 2*mu*e33(du1,du2,du3,u1,u2,u3)) //

macro oS12(du1,du2,du3, u1,u2,u3) (2*mu*e12(du1,du2,du3,u1,u2,u3)) //
macro oS13(du1,du2,du3, u1,u2,u3) (2*mu*e13(du1,du2,du3,u1,u2,u3)) //
macro oS23(du1,du2,du3, u1,u2,u3) (2*mu*e23(du1,du2,du3,u1,u2,u3)) //

// Incremental linear strain (eij)
macro e11(du1,du2,du3, u1,u2,u3) (dx(du1) + dx(u1)*dx(du1) + dx(u2)*dx(du2) + dx(u3)*dx(du3)) //
macro e22(du1,du2,du3, u1,u2,u3) (dy(du2) + dy(u1)*dy(du1) + dy(u2)*dy(du2) + dy(u3)*dy(du3)) //
macro e33(du1,du2,du3, u1,u2,u3) (dz(du3) + dz(u1)*dz(du1) + dz(u2)*dz(du2) + dz(u3)*dz(du3)) //
// Incremental linear strain (eij) - CORRECTED
macro e12(du1,du2,du3, u1,u2,u3) (0.5*(dy(du1) + dx(du2) + (dx(du1)*dy(u1) + dx(u1)*dy(du1)) + (dx(du2)*dy(u2) + dx(u2)*dy(du2)) + (dx(du3)*dy(u3) + dx(u3)*dy(du3)) )) //
macro e13(du1,du2,du3, u1,u2,u3) (0.5*(dz(du1) + dx(du3) + (dx(du1)*dz(u1) + dx(u1)*dz(du1)) + (dx(du2)*dz(u2) + dx(u2)*dz(du2)) + (dx(du3)*dz(u3) + dx(u3)*dz(du3)) )) //
macro e23(du1,du2,du3, u1,u2,u3) (0.5*(dz(du2) + dy(du3) + (dy(du1)*dz(u1) + dy(u1)*dz(du1)) + (dy(du2)*dz(u2) + dy(u2)*dz(du2)) + (dy(du3)*dz(u3) + dy(u3)*dz(du3)) )) //
macro tre(du1,du2,du3, u1,u2,u3) (e11(du1,du2,du3,u1,u2,u3) + e22(du1,du2,du3,u1,u2,u3) + e33(du1,du2,du3,u1,u2,u3)) //

// Variation of linear strain (deij)
macro de11(v1,v2,v3, u1,u2,u3) (dx(v1) + dx(u1)*dx(v1) + dx(u2)*dx(v2) + dx(u3)*dx(v3)) //
macro de22(v1,v2,v3, u1,u2,u3) (dy(v2) + dy(u1)*dy(v1) + dy(u2)*dy(v2) + dy(u3)*dy(v3)) //
macro de33(v1,v2,v3, u1,u2,u3) (dz(v3) + dz(u1)*dz(v1) + dz(u2)*dz(v2) + dz(u3)*dz(v3)) //

// Variation of linear strain (deij) - CORRECTED
macro de12(v1,v2,v3, u1,u2,u3) (0.5*(dy(v1) + dx(v2) + (dx(v1))*(dy(u1)) + (dx(u1))*(dy(v1)) + (dx(v2))*(dy(u2)) + (dx(u2))*(dy(v2)) + (dx(v3))*(dy(u3)) + (dx(u3))*(dy(v3)))) //

macro de13(v1,v2,v3, u1,u2,u3) (0.5*(dz(v1) + dx(v3) + (dx(v1))*(dz(u1)) + (dx(u1))*(dz(v1)) + (dx(v2))*(dz(u2)) + (dx(u2))*(dz(v2)) + (dx(v3))*(dz(u3)) + (dx(u3))*(dz(v3)))) //

macro de23(v1,v2,v3, u1,u2,u3) (0.5*(dz(v2) + dy(v3) + (dy(v1))*(dz(u1)) + (dy(u1))*(dz(v1)) + (dy(v2))*(dz(u2)) + (dy(u2))*(dz(v2)) + (dy(v3))*(dz(u3)) + (dy(u3))*(dz(v3)))) //

// Variation of incremental nonlinear strain (dnij)
macro dn11(du1,du2,du3, v1,v2,v3) (dx(v1)*dx(du1) + dx(v2)*dx(du2) + dx(v3)*dx(du3)) //
macro dn22(du1,du2,du3, v1,v2,v3) (dy(v1)*dy(du1) + dy(v2)*dy(du2) + dy(v3)*dy(du3)) //
macro dn33(du1,du2,du3, v1,v2,v3) (dz(v1)*dz(du1) + dz(v2)*dz(du2) + dz(v3)*dz(du3)) //

macro dn12(du1,du2,du3, v1,v2,v3) (0.5*(dx(v1)*dy(du1) + dy(v1)*dx(du1) + dx(v2)*dy(du2) + dy(v2)*dx(du2) + dx(v3)*dy(du3) + dy(v3)*dx(du3)) ) //
macro dn13(du1,du2,du3, v1,v2,v3) (0.5*(dx(v1)*dz(du1) + dz(v1)*dx(du1) + dx(v2)*dz(du2) + dz(v2)*dx(du2) + dx(v3)*dz(du3) + dz(v3)*dx(du3)) ) //
macro dn23(du1,du2,du3, v1,v2,v3) (0.5*(dy(v1)*dz(du1) + dz(v1)*dy(du1) + dy(v2)*dz(du2) + dz(v2)*dy(du2) + dy(v3)*dz(du3) + dz(v3)*dy(du3)) ) //


varf vMass([du1,du2,du3], [v1,v2,v3]) = int3d(Th)(rho * (du1*v1 + du2*v2 + du3*v3));

// Assemble the consistent mass matrix
matrix Mconsistent = vMass(Vh3, Vh3);

real[int] ones(Vh3.ndof);
ones = 1.0;

// Use the row-sum lumping shortcut to get the diagonal vector
real[int] Mlumpeddiag = Mconsistent * ones; // Dofones is a built-in vector of 1s

// Create the final, constant, lumped (diagonal) mass matrix M
matrix M = Mlumpeddiag;

cout << "Lumped Mass Matrix M constructed." << endl;

//variatonal form to solve residual 
varf residual([du1,du2,du3], [v1,v2,v3]) =

    // Internal forces (Sij::deij)
    - int3d(Th)( 
           S11*de11(v1,v2,v3, u1,u2,u3) 
         + S22*de22(v1,v2,v3, u1,u2,u3)
         + S33*de33(v1,v2,v3, u1,u2,u3)  
         + 2*S12*de12(v1,v2,v3, u1,u2,u3)
         + 2*S13*de13(v1,v2,v3, u1,u2,u3) 
         + 2*S23*de23(v1,v2,v3, u1,u2,u3)  
    )

    //External forces (only gravity for now, fluid force to be added)
    + int3d(Th)( 
        rho * g * v3
    )

    + on(10, du1=0, du2=0, du3=0);
    

varf tangent([du1,du2,du3], [v1,v2,v3]) =
    // Material Part (K_L), written in the safe, flat sum-of-products form
    int3d(Th)(
          de11(v1,v2,v3, u1,u2,u3) * oS11(du1,du2,du3, u1,u2,u3)
        + de22(v1,v2,v3, u1,u2,u3) * oS22(du1,du2,du3, u1,u2,u3)
        + de33(v1,v2,v3, u1,u2,u3) * oS33(du1,du2,du3, u1,u2,u3)
        + 2*de12(v1,v2,v3, u1,u2,u3) * oS12(du1,du2,du3, u1,u2,u3)
        + 2*de13(v1,v2,v3, u1,u2,u3) * oS13(du1,du2,du3, u1,u2,u3)
        + 2*de23(v1,v2,v3, u1,u2,u3) * oS23(du1,du2,du3, u1,u2,u3)
    )
    // Geometric Part (K_NL)
    + int3d(Th)(
          S11*dn11(du1,du2,du3, v1,v2,v3) + S22*dn22(du1,du2,du3, v1,v2,v3) + S33*dn33(du1,du2,du3, v1,v2,v3)
        + 2*S12*dn12(du1,du2,du3, v1,v2,v3) + 2*S13*dn13(du1,du2,du3, v1,v2,v3) + 2*S23*dn23(du1,du2,du3, v1,v2,v3)
    )

    + on(10, du1=0, du2=0, du3=0);

for (int step = 1; step <= nsteps; ++step) {

    real t = step * dt;
    cout << "Time step: " << step << " (t = " << t << ")" << endl;

    matrix Ktangent = tangent(Vh3, Vh3, solver=UMFPACK);
    matrix Keff = (1. + beta * 2./dt) * Ktangent + (4./(dt*dt) + alpha * 2./dt) * M;  //Included damping C = alpha*M + beta*K

    // 2. THIS IS THE CRITICAL FIX:
    //    Associate a solver with Keff and pre-factorize it.
    set(Keff, solver=UMFPACK);

    for (int iter = 0; iter < maxiter; ++iter) {
        
        real[int] R = residual(0, Vh3); 

        // This will now work correctly
        real[int] temp(at1[].n); // .n gives the size of the DoF vector

        // Perform the operation step-by-step
        temp = u1[] - ut1[];
        temp *= (4. / (dt*dt));
        temp -= (4. / dt) * vt1[];

        // The final, simple assignment should now work
        an1[] = temp - at1[];

        real[int] inertialForce = M * an1[];
        R -= inertialForce;
        real normR = R.l2;
        cout << "  NR Iter: " << iter << ", Residual Norm = " << normR << endl;

        // 3. CHECK FOR CONVERGENCE
        if (normR < tol) {
            cout << "  -> CONVERGED" << endl;
            
            // Update the total stress tensor.
            // The displacement increment for the whole step is u1[] - un1[].
            Du1[] = u1[] - ut1[];

            Vh deltaS11 = oS11(Du1, Du2, Du3, u1, u2, u3); 
            Vh deltaS22 = oS22(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS33 = oS33(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS12 = oS12(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS13 = oS13(Du1, Du2, Du3, u1, u2, u3);
            Vh deltaS23 = oS23(Du1, Du2, Du3, u1, u2, u3);
            
            S11[] += deltaS11[]; S22[] += deltaS22[]; S33[] += deltaS33[];
            S12[] += deltaS12[]; S13[] += deltaS13[]; S23[] += deltaS23[];
            
            // UPDATE STATE FOR THE NEXT STEP
            ut1[] = u1[]; 
            vt1[] = vk1[];
            at1[] = ak1[];
            
            
            break; // Exit the Newton-Raphson loop
        }
        
       
        // Solve for the correction
        du1[] = Keff^-1 * R;

        // 5. UPDATE THE DISPLACEMENT GUESS
        u1[] += du1[];

        //update acc and vel guesses
        temp = u1[] - ut1[];          
        temp *= (2. / dt);         
        vk1[] = temp - vt1[];      

        temp = u1[] - ut1[];          
        temp *= (4. / (dt*dt));     
        temp -= (4. / dt) * vt1[]; 
        ak1[] = temp - at1[];   
        
        if(iter == maxiter - 1){
            cout << "  WARNING: Max iterations reached without convergence." << endl;
        }
    }
}


plot(u1, cmm="Final X Displacement (u1)", value=true, fill=true, wait=true);
plot(u2, cmm="Final Y Displacement (u2)", value=true, fill=true, wait=true);
plot(u3, cmm="Final Z Displacement (u3)", value=true, fill=true, wait=true);


// 2. Plotting the Magnitude of the Displacement Vector
// ----------------------------------------------------
// It's often more useful to see the total magnitude of displacement.
// We need a scalar (P1) space to define this function.
fespace Vh1(Th, P1);
Vh1 umagnitude = sqrt(u1^2 + u2^2 + u3^2);
plot(umagnitude, cmm="Displacement Magnitude", value=true, fill=true, wait=true);


// 3. Visualizing the Deformed Mesh using movemesh
// ------------------------------------------------
// 'movemesh' creates a NEW mesh object where the coordinates of each vertex
// have been updated by the displacement vector [u1, u2, u3].
mesh3 ThDeformed = movemesh(Th, [x+u1, y+u2, z+u3]);

// Now, plot the new, deformed mesh.
plot(ThDeformed, cmm="Deformed Mesh", value=true, wait=true);
plot(Th, cmm="Original", value=true, boundary=true, wait=true); // Plot original boundary
plot(ThDeformed, cmm="Deformed Mesh", value=true, wait=true);
medit("3D Mesh", ThDeformed);